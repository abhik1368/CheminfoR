install.packages("rcdk")
install.packages("ggplot2")
install.packages("shiny")
install.packages('iplot')
install.packages('Ggobi')
install.packages('GGobi')
install.packages('e1071')
install.packages('cluster')
install.packages('randomforest')
install.packages('randomForest')
install.packages('reshape2')
install.packages('plyr')
install.packages('colorspace')
install.packages('zoo')
install.packages('RCurl')
install.packages('rpart')
install.packages('gdata')
install.packages('googleVis')
install.packages('knitr')
install.packages('Matrix')
install.packages('igraph')
install.packages('reshape')
install.packages('maps')
install.packages('nlme')
install.packages('DBI')
install.packages('XML')
install.packages('scatterplot3d')
install.packages('kernlab')
install.packages('vegan')
install.packages('XLConnect')
install.packages('devtools')
install.packages('RJSONIO')
install.packages('vcd')
install.packages('lattice')
install.packages(c("car","gregmisc","xtable","Design","Hmisc","psych",
"CCA", "fda", "zoo", "fields",
"catspec","sem","multilevel","Deducer","RQDA"))
install.packages('SDMTools')
install.packages(SDMTools)
install.packages('SDMTools')
install.packages("SDMTools")
tasc = as.asc(matrix(rep(x=1:10, times=1000),nr=100)); print(tasc)
#modify the asc objects so that they are slightly different
tasc1 = tasc + runif(n = 10000, min = -1, max = 1)
tasc2 = tasc + rnorm(n = 10000, mean = 1, sd = 1)
library(SDMTools)
tasc = as.asc(matrix(rep(x=1:10, times=1000),nr=100)); print(tasc)
#modify the asc objects so that they are slightly different
tasc1 = tasc + runif(n = 10000, min = -1, max = 1)
tasc2 = tasc + rnorm(n = 10000, mean = 1, sd = 1)
compare.matrix(tasc1,tasc2,20)
compare.matrix(tasc1,tasc2,50)
head(tasc1)
head(tasc2)
install.packages('ROCR')
library(ROCR)
data(ROCR.simple)
data(ROCR.simple)
pred <- prediction( ROCR.simple$predictions, ROCR.simple$labels )
perf <- performance( pred, "tpr", "fpr" )
plot( perf )
ROCR.simple$predictions
ROCR.simple$labels
ROCR.simple
install.packages('compare')
library(compare)
a1 <- data.frame(a = 1:5, b = letters[1:5])
a1
a2 <- data.frame(a = 1:3, b = letters[1:3])
a2
comparison <- compare(a1,a2,allowAll=TRUE)
comparison
comparison$tM
count(comparison$tM)
install.packages("RGtk2")
library(rattle)
rattle()
library(RGtk2)
rattle()
library(RGtk2)
demo(appWindow)
demo(package="RGtk2")
demo(appWindow)
demo(appWindow)
win = gtkWindow()
install.packages("~/Downloads/cairoDevice_2.19.tgz", repos = NULL)
library(rattle)
crv$rattleUI <- "rattle_macosx.ui"
rattle()
install.packages("~/Downloads/RGtk2_2.20.25.tgz", repos = NULL)
library(RGtk2)
library(rattle)
crv$rattleUI <- "rattle_macosx.ui"
rattle()
library(RGtk2)
library(rattle)
crv$rattleUI <- "rattle_macosx.ui"
rattle()
rattle()
Iris
IRIS
iris
getwd()
setwd("/Users/abhikseal/CheminformaticsMOOC")
write.csv(iris,"iris.csv")
d<-read.csv("mutagendata.csv",header=T)
head(d)
d<-read.csv("mutagendata.csv",header=T,row.names=1)
head(d)
dat1<-read.csv("mutagendata.smi",sep="\t",header=F)
smi <-lapply(as.character(dat1$V1),parse.smiles)
cmp.fp<-vector("list",nrow(dat1))
getwd()
setwd("Users/abhikseal/CheminformaticsMOOC/CheminfoR/")
setwd("~/CheminformaticsMOOC/CheminfoR")
ls
clear
cls
library(ROCR)
library(randomForest)
library(party)
library(rcdk)
library(kernlab)
library(e1071)
source('classificationsummary.R')
dat1<-read.csv("mutagendata.smi",sep="\t",header=F)
smi <-lapply(as.character(dat1$V1),parse.smiles)
cmp.fp<-vector("list",nrow(dat1))
## generate fingerprints
for (i in 1:nrow(dat1)){
cmp.fp[i]<-lapply(smi[[i]][1],get.fingerprint,type="maccs")
}
##Convert fingerprints to matrix form
fpmac<-fp.to.matrix(cmp.fp)
cmp.finger<-as.data.frame(fpmac)
#Adding Outcome column and ID columns
dataset<-cbind(cmp.finger,dat1$V3,dat1$V2)
colnames(dataset)[168]<-"IDs"
colnames(dataset)[167]<-"Outcome"
ind<-sample(2,nrow(dataset),replace=TRUE,prob=c(0.8,0.2))
trainset<-dataset[ind==1,]
testset<-dataset[ind==2,]
## Modeling with three algorithm Naive Bayes, Random Forest and SVM
rf_model<-randomForest(trainset[1:166],trainset$Outcome,ntree=500,proximity=TRUE)
nb_model<-naiveBayes(trainset[1:166],trainset$Outcome)
svm_model<-ksvm(as.matrix(trainset[1:166]),as.matrix(trainset$Outcome),data=trainset,type="C-svc",C=100,scaled=c(),prob.model=TRUE)
predict_nb<-predict(nb_model,newdata=testset,type="raw")
pred.nb<-prediction(predict_nb[,2],testset$Outcome)
nb.auc<-performance(pred.nb,'tpr','fpr')
#For Random Forest Model
#table(predict(rf), trainset$Outcome)
#print(rf)
#predict_rf<-predict(rf_model,newdata=testset)
#table(predict_rf, testset$Outcome)
predict_rf<-predict(rf_model,newdata=testset,type="prob")
pred.rf<-prediction(predict_rf[,2],testset$Outcome)
rf.auc<-performance(pred.rf,'tpr','fpr')
#For SVM Model
predict_svm<-predict(svm_model,as.matrix(testset[1:166]),type='prob')
pred.svm<-prediction(predict_svm[,2],testset$Outcome)
svm.auc<-performance(pred.svm,'tpr','fpr')
plot(rf.auc,col='red',lty=1,main='ROC Curve Comparison of Random Forest V/s Naive Bayes')
plot(nb.auc,col='green',add=TRUE,lty=2)
plot(svm.auc,col='black',add=TRUE,lty=2)
L<-list(bquote("Random Forest"== .(rfauc)), bquote("Naive Bayes"== .(nbauc)),bquote("SVM"== .(svmauc)))
legend("bottomright",legend=sapply(L, as.expression),col=c('red','green','black'),lwd=2,bg="gray",pch=14,text.font=2,cex=0.6)
L<-list(bquote("Random Forest"== .(rfauc)), bquote("Naive Bayes"== .(nbauc)),bquote("SVM"== .(svmauc)))
rfauc<-performance(pred.rf,"auc")@y.values[[1]]
nbauc<-performance(pred.nb,"auc")@y.values[[1]]
svmauc<-performance(pred.svm,"auc")@y.values[[1]]
L<-list(bquote("Random Forest"== .(rfauc)), bquote("Naive Bayes"== .(nbauc)),bquote("SVM"== .(svmauc)))
legend("bottomright",legend=sapply(L, as.expression),col=c('red','green','black'),lwd=2,bg="gray",pch=14,text.font=2,cex=0.6)
data(bpdata)
head(bpdata)
query.mol <- parse.smiles("CC(=O)")[[1]]
target.mols <- parse.smiles(bpdata[, 1])
query.fp <- get.fingerprint(query.mol, type = "maccs")
target.fps <- lapply(target.mols, get.fingerprint, type = "maccs")
sims <- unlist(lapply(target.fps, distance, fp2 = query.fp,
+ method = "tanimoto"))
hits <- which(sims > 0.3)
sims <- unlist(lapply(target.fps, distance, fp2 = query.fp,method = "tanimoto"))
hits <- which(sims > 0.3)
hits
sims
class(sims)
head(sims)
head(data.frame(sims))
hits<-sort(data.frame(sims))
hits<-data.frame(sims)
hits<-sort(hits$sims)
head(hits)
sims <- unlist(lapply(target.fps, distance, fp2 = query.fp,method = "tanimoto"))
hits<-data.frame(sims),ordered=TRUE)
hits<-data.frame(sims)
sort(hits,by=sims)
sort(hits,by=~sims)
sort(hits,by=hits$sims)
hits
orderBy(~sims,data=hits)
hits[with(hits,order(sims))]
hits[with(hits,order(hits$sims))]
head(hits)
hits <- data.frame(which(sims > 0.3))
head(hits)
hits<-do.call("rbind",data.frame(sims))
head(hits)
hits<-data.frame(sims)
hits
query.mol <- parse.smiles("CC(=O)")[[1]]
target.mols <- parse.smiles(bpdata[, 1])
query.fp <- get.fingerprint(query.mol, type = "pubchem")
target.fps <- lapply(target.mols, get.fingerprint, type = "pubchem")
sims <- unlist(lapply(target.fps, distance, fp2 = query.fp,method = "tanimoto"))
hits <- which(sims > 0.5)
hit_sim<-data.frame(hits)
head(hit_sim)
head(hits)
head(data.frame(sims))
view.molecule.2d(query.mol)
smiles <- c("CCC", "CCN", "CCN(C)(C)", "c1ccccc1Cc1ccccc1","C1CCC1CC(CN(C)(C))CC(=O)CC")
mols <- parse.smiles(smiles)
view.molecule.2d(mols)
mols <- parse.smiles(smiles)
view.molecule.2d(mols)[[1]]
mols <- parse.smiles(smiles)
view.molecule.2d(mols[[1]])
mols <- parse.smiles(smiles)
view.molecule.2d(mols)
